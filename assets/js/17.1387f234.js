(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{363:function(t,a,e){"use strict";e.r(a);var r=e(9),s=Object(r.a)({},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"浏览器底层原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器底层原理","aria-hidden":"true"}},[t._v("#")]),t._v(" 浏览器底层原理")]),t._v(" "),e("p",[t._v("html、css以及js是前端的三驾马车，浏览器为何只解析这三种语言？为何又有这么多不同的浏览器厂家，他们都做了些什么？浏览器底层又是如何通过渲染引擎以及JS引擎把网页呈现给用户？带着疑问去找寻答案。")]),t._v(" "),e("h2",{attrs:{id:"渲染引擎"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#渲染引擎","aria-hidden":"true"}},[t._v("#")]),t._v(" 渲染引擎")]),t._v(" "),e("p",[t._v("浏览器内核"),e("code",[t._v("又叫渲染引擎，主要负责 HTML、CSS 的解析，页面布局、渲染与复合层合成")]),t._v("。浏览器内核的不同带来的主要问题是对 CSS 的支持度与属性表现差异。")]),t._v(" "),e("p",[t._v("现在主流的内核有：Blink、Webkit、Gecko、EdgeHTML、Trident，这里面有几个需要注意的地方：")]),t._v(" "),e("ul",[e("li",[t._v("Blink 是在 Webkit 的基础上的改进，是现在对新特性支持度最好的内核")]),t._v(" "),e("li",[t._v("移动端基本上全部是 Webkit 或 Blink 内核（除去 Android 上腾讯家的 X5），这两个内核对新特性的支持度较高，所以新特性可以在移动端大展身手。")]),t._v(" "),e("li",[t._v("Trident 是 IE4+ 的内核，一直持续到 IE11，EdgeHTML 是微软抛弃 IE 后开发的全新内核")])]),t._v(" "),e("blockquote",[e("p",[t._v("Chromium内核架构，包含Blink渲染引擎和V8 JS引擎。简单理解是阉割版Chrome浏览器。")])]),t._v(" "),e("h2",{attrs:{id:"javascript-引擎"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript-引擎","aria-hidden":"true"}},[t._v("#")]),t._v(" JavaScript 引擎")]),t._v(" "),e("p",[e("code",[t._v("负责 JavaScript 代码的解释与执行")]),t._v("，主流的 JavaScript 引擎有：V8、SpiderMonkey、JavaScriptCore、Chakra。")]),t._v(" "),e("h3",{attrs:{id:"v8"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v8","aria-hidden":"true"}},[t._v("#")]),t._v(" V8")]),t._v(" "),e("p",[t._v("JavaScriptCore是WebKit的默认引擎，在谷歌系列产品中被替换为V8引擎。")]),t._v(" "),e("p",[t._v("V8 是谷歌开发的高性能 JavaScript 引擎，该引擎使用 C++ 开发。在V8引擎中，源代码先被解析器转变为抽象语法树(AST)，然后使用JIT编译器的全代码生成器从AST直接生成本地可执行代码。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("JavaScriptCore 的大致流程为：源代码-→抽象语法树-→字节码(可优化阶段)-→JIT-→本地代码。")])]),t._v(" "),e("li",[e("p",[t._v("V8 的大致流程为：源代码-→抽象语法树-→JIT-→本地代码（在此优化）。")])])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-images.githubusercontent.com/6310131/57189210-320ed880-6f3e-11e9-8328-941607c36e76.png",alt:"image"}})]),t._v(" "),e("h4",{attrs:{id:"性能比较"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能比较","aria-hidden":"true"}},[t._v("#")]),t._v(" 性能比较")]),t._v(" "),e("p",[t._v("JS是边解释边编译，Java是提前编译。Java在编译阶段把AST转换为字节码，同时做着优化，最后生成可直接执行的本地代码。所以从语言层面讲，JS的性能与Java、C++不再同一个层次上。但边解释边编译意味着js语言更加灵活，易用，同时V8引擎也在不断优化性能，赋能js更多领域。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-images.githubusercontent.com/6310131/57189215-4652d580-6f3e-11e9-83c8-9b64b07bb9fb.png",alt:"image"}})]),t._v(" "),e("h2",{attrs:{id:"js引擎和渲染引擎关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js引擎和渲染引擎关系","aria-hidden":"true"}},[t._v("#")]),t._v(" JS引擎和渲染引擎关系")]),t._v(" "),e("p",[t._v("在"),e("router-link",{attrs:{to:"/js/http-base-1.url.html"}},[t._v("输入URL背后的技术步骤")]),t._v("中，详细说了浏览器是如何解析html、css以及js，并呈现最终的网页出来。重点是渲染引擎遇到js代码会通知让JS引擎解析，然后JS引擎解释执行后，通过DOM改变并渲染网页（这部分工作属于渲染引擎）。")],1),t._v(" "),e("p",[t._v("JavaScript引擎和渲染引擎的关系如下图所示：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-images.githubusercontent.com/6310131/57189224-5bc7ff80-6f3e-11e9-9dd0-2c7bfb5ec14c.png",alt:"image"}})]),t._v(" "),e("blockquote",[e("p",[t._v("JavaScript是一种动态类型语言，函数也是类型的一种，所以可以把函数当作参数值进行传递（这就是FP中常说的函数天生是“一等公民”）")])])])},[],!1,null,null,null);s.options.__file="http-base-2.browser.md";a.default=s.exports}}]);