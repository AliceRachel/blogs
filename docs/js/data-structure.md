# 数据结构

## 1. 线性表

`线性表是为了解决单线存储而出现的`。最基础结构为数组和链表，栈和堆是线性表的特殊形态，在操作上进行了限制。构造一个栈或堆结构，既可以使用数组，也可以使用链表。

### 1.1 数组

数组：就是`最简单粗暴的存储方法`。就是直接拉出一大块数据存在那里。数组的快速存取其实只是一个副作用，因为所有的数据都在一起，可以直接算出来数据的地址。数组的优势是连续内存，可以快速读取。缺点是插入比较困难，需要后面数据挪位置。

> c/c++语言的数组更接近数据结构的数组概念，默认是不能动态扩容的。js高级语言的数组概念就包含更多，比如动态扩容、语言层自实现栈、队列特性。

### 1.2 链表

链表：则是为了`解决可以无线增长的需求`。因为找不到一大块可以连续的存入数据，甚至也不知道程序可能使用的数据总量，所以就没办法划分一块数据来使用，划小了不够用，划大了浪费（这在早年是非常大的事情）。所以必须想办法解决问题。最后采用的方法就是从入口开始，每一个数据块不仅仅有数据，还会有指向下一个数据块的线索，用来寻找下一个数据。这就是链表。

所谓的双向链表，只是加了一个向前的线索的链表而已。不仅如此，队列，栈，都是线性表的特殊形态。进行了操作上的限制罢了。既可以是数组，也可以是链表。

> 数组和链表都是一种数据结构，数组是开辟整块内存，链表则拥有next指针，指向下一个node节点。

### 1.3 堆、栈/队列
`都是一种数据结构`。
* 堆：堆是一种`经过排序的树形数据结构`，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆(有序)。由于堆的这个特性，常用来实现优先队列。`堆的存取是随意`，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。
* 栈：属于一维线性关系，加上`后进先出`规则。后存放的先取，先存放的后取，无法从中间插入和删除。
* 队列：也属于一纬关系，`先进先出`规则。

> 千万不要把堆和队列搞混了，它们是三种不同的数据结构，栈和队列相似，堆完全不同。

#### 堆和栈的应用

* 栈：最常见的应用就是`执行栈`，当有大函数嵌套小函数时，先逐一把所有函数压入栈中。依据后进先出，先执行最后的小函数，直到执行完所有函数。
* 堆：在js等高级语言中，基本类型有Undefined、Null、Boolean、Number 和String。这些类型在内存中分别占有固定大小的空间，所以使用栈空间来保存。而`引用类型`，你根本不知道这个类型要用多大的内存空间，所以使用堆存储最好不过。

#### 为什么会有`栈内存`和`堆内存`之分？

通常与垃圾回收机制有关。为了使程序运行时占用的内存最小。

 当一个方法执行时，`每个方法都会建立自己的内存栈`，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；

当我们在程序中`创建一个对象时，这个对象将被保存到运行时数据区中`，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。`堆内存中的对象不会随方法的结束而销毁`，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。

在c语言这类没有垃圾回收机制的语言中，定义基本类型如char时，系统会自动在栈上为其开辟空间，而堆是需要程序员自己申请空间，如malloc(10)。由于栈上的空间是自动分配自动回收的，所以栈上的数据的生存周期只是在函数的运行过程中，运行后就释放掉，不可以再访问。而堆上的数据只要程序员不释放空间，就一直可以访问到，不过缺点是一旦忘记释放会造成内存泄露。

### 1.4 总结

* 数组（连续存储）；
* 链表（离散存储）；
    * 有序表：要求插入元素时，对元素对值进行比较，以找到相应的插入位置。
    * 顺序表、单链表、循环链表、双向链表
* 栈（线性结构常见应用，由链表或数组增删和改进功能实现），特点是先进后出；
* 队列（线性结构常见应用，由链表或数组增删和改进功能实现），特点是先进先出；

数组和链表是最基础的数据结构，`相同的功能实现可以用数组结构，也可以用链表结构`，如栈与队列的实现，可以底层存储是用数组，也可以是小块内存链接起来的链表。再比如数组的reverse翻转，使用数组或链表数据结构，相关算法是完全不一样的。
``` c
// c++数组reverse
// 数组reverse思路：left、right分别是两头，值互相换，然后left递增1，right递减1

//定义了一个数据类型，该数据类型的名字叫做struct Arr, 该数据类型含有三个成员，分别是pBase, len, cnt
struct Arr
{
    int * pBase; //存储的是数组第一个元素的地址
    int len; //数组所能容纳的最大元素的个数
    int cnt; //当前数组有效元素的个数
};
void reverse(struct Arr * pArr) {
    int i = 0;
    int j = pArr->cnt-1; // 末尾index
    int t;
    // 当i<j时，置换i和j位置的元素 
    while(i < j) {
        t = pArr->pBase[i];
        pArr->pBase[i] = pArr->pBase[j];
        pArr->pBase[j] = t;
        ++i;
        --j;
    }
    return;
}
```

``` c++
// c++链表reverse
// 不同数据结构间，都可以实现reverse，但使用的方式有很大差别
// 链表reverse思路：递归，通过不断重组第二项，即先从后往前，不断完成next构建
struct node {
    int payload;
    node* next;
}

// 递归的核心思想是找到规律，这里规律是只关注第二个和第一个的反向链接，优先把最后执行
node* reverse(node* head) { // 链表是一个head为入口的链路
    if (head == nullptr || head->next == nullptr) {
        return head;
    }
    node* seconde = head->next;
    node* new_head = reverse(second); // 重点：不断优先整理完最后的node
    // 重构第二个与第一个的反向关系
    second->next = head;
    head->next = nullptr;

    return new_head;
}
```

## 2. 树

树是为了解决单一入口下的非线性关联性的数据存储或者排序这样的功能而来的。
* 二叉树
* B树、B+树
* 红黑树

最常见的应用是编程时候的map，就是利用了二叉树的可排序和可以快速插入并且保持序列完整的特性来构建键值数据对，来实现数据的插入增加以及快速查找的能力的。

还有做语法解析，文字处理等等很多场景也会用到树。这就不一一赘述了。当然在吃透线性表的基础上，再去理解树也并不难。因为在本质上，树相对于链表，就是每个节点不止有一个后续节点但是只有一个前置节点。

## 3. 图

## 算法
通过算法来学习数据结构很有效。

常见算法：
* 深度优先搜索
* 广度优先搜索
* 二分法
* 贪心算法
* 分治法
* 回溯法

### 二分法

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

``` js
// https://leetcode-cn.com/problems/binary-search
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    // 二分法，二分下标
    var left = 0, right = nums.length - 1
    while(left <= right) {
        let mid = left + Math.floor((right - left) / 2)
        if (nums[mid] === target) return mid
        if (nums[mid] > target) right = mid - 1 // 最大值为mid-1
        else left = mid + 1 // 最小值为mid + 1
    }
    return -1
};
```

``` js
// 二分法套路
function dic() {
    // 左边界
    var left ...
    // 右边界
    var right ...
    // 记录答案
    var ans
    while(left < right) {
        // 中间值
        var middle = Math.floor((left + right) / 2)
        // 猜测是否满足条件
        if (guess(middle, ...)) {
            // 如果满足条件，记录答案
            ans = middle
            // 缩小搜索范围，在更小的值中搜索
            right = middle - 1
        } else  {
            // 在更大的值中搜索
            left = middle + 1
        }
    }
    return ans
}
```