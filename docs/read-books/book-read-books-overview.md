# 读书精要

## 1. 《金字塔原理》

* 说话思考时，按照金字塔思想论述，而不是照顾到所有细节点（不啰嗦）。另外灵活应用归纳法。
* 纸质说明：STAR法则，情境-任务-行动-结果。事情什么情况发生-你如何明确你的任务-针对情况分析，你采用了什么行动-结果如何，学习到了什么。

### 1.1 展示金字塔

短信息，使用书面或邮件的方式记录；长信息，使用ppt记录。
`观众总是先看到逻辑关系的存在，然后才能理解它`。
* 多级标题法
* 下划线法
* 小数编号法
* 行首缩进法

### 1.2 PPT展示

#### 1.2.1 ppt展示原则

1. 只包含最重要的、经过适当分组和总结的思想观点，叙述时尽量简洁
1. 演示应尽量用各种图表配合（理想比例是90%图表，10%文本），图表也尽量简单易懂
1. 演示反映经过深思熟虑后的剧本。

#### 1.2.2 知道你要演示什么

1. 每次只演示和说明一个论点
1. 论点使用简短陈述性语言，而不是标题性语言（做到观众不误解）
1. 文本尽量简短，使用简单的单词和数字，字号足够大
1. 增加趣味性（比如不同组织部分逐一显示，边演示边解释）

![image](https://user-images.githubusercontent.com/6310131/68274785-fbf51180-00a4-11ea-8ec8-534d8f09587c.png)

![image](https://user-images.githubusercontent.com/6310131/68276699-855a1300-00a8-11ea-9544-c7d64890f963.png)

## 2.《少有人走的路》

* 延迟满足感：先做困难的事，先苦后甜
* 责任感：不要把责任推卸到别人头上

## 3.《7个好习惯》

* 向上管理：时刻汇报当前工作内容，有困难提前提
* 做自己的Owner：要有owner思维，多去思考整体大盘，而不是仅仅在你的专业

## 4. 《影响力》

有点心理学的范畴，讲述影响你生活行为的一些因素。举几个案例：
* 我们在要别人帮忙时，给出一个理由，得到帮助的概率会大增。
* 对比原则：当你买衣服首先买好了贵的西装，再买相对便宜的配饰会容易接受的多；当你买了车，车的配饰以及保险会好卖的多。
* 涨价去库存原则：因为人性贪利，都会愿意去赌这个价值会更高。
* 垫底原则：看房时先看较差的地方，后面稍微好点的地方就更容易接受。

常有的因素：
1. 互惠
    * 为什么超市总喜欢提供“免费试用”
1. 承诺
    * 当你向陌生人承诺保管他东西时，基本上这东西就不会丢。
1. 社会认同
    * 中国式过马路，从众原则。
1. 喜好
    * 你更喜欢与自己有相同经历/偏好/运动的人。
    * 漂亮姑娘当车模，爱屋及乌。
1. 权威。具有独立思考的成年人也会为了服从权威命令，而作出一些完全丧失理智的事。
    * 为什么行骗高手总是以换装作为一种手段
1. 稀缺。失去某种东西的恐惧，比得到这东西的渴望，更具有行动性。
    * 自由可以减少，但你不能完全没自由。

## 5. 《拖延心理学》

## 6. 《领导力法则》

* 影响力法则
* 过程法则
    * 领导力不是一蹴而就，而是经年累月

## 7.《Python 深度学习》

### 1. 深度学习

深度学习是机器学习的一个分支领域，而机器学习属于人工智能的范畴。机器学习（特别是深度学习），较少的数学理论，并且以工程为导向，需要上手实践的学科。

`利用机器学习，输入的是数据和从这些数据中预期得到的答案，系统输出的是规则。`这些规则随后可用于新的数据，并使计算机自主生成答案。

机器学习是将输入（比如图像）映射到目标（比如标签“猫”），这一过程是通过观察许多输入和目标的示例来完成的。

#### 神经网络

在深度学习中，分层几乎都是通过`神经网络`的模型来学习得到的。`神经网络中每层对输入数据所做的具体操作保存在该层的权重中，其本质上是一串数字`。
* 每层实现的变化由其权重来`参数化`，

> 从技术角度上看，就是把待分类的图像拆分成许多通道像素点，这些数据通过坐标转换（模型），最终得到期待值。这个期待值一开始可能是错的，但通过不断迭代学习，可以提高这个期待着的概率。

## 8. 《深入浅出NodeJS》

### request
对TCP连接的读操作，http模块将其封装为ServerRequest对象。报文头通过http_parser进行解析
* `报文头第一行（请求行）`如： GET / HTTP/1.1
    * req.method
    * req.url
    * req.httpVersion
* `其余报头（首部字段）是很规律的`
    * req.headers
* `报文体部分抽象为一个只读流`。如果业务逻辑要读取报文中的数据，要在这个数据流结束后才能操作。如：
``` js
function(req, res) {
    var buffers = []
    req.on('data', trunk => buffers.push(trunk))
    req.on('end', () => {
        var buffer = Buffer.concat(buffers)
        // TODO
        res.end('hello world')
    })
}
```
> HTTP请求对象和HTTP响应对象是相对较底层的封装，现行的Web框架如Connect和Express都是在这两个对象的基础上进行高层封装的。

### response

* 报文体头api：res.setHeader和res.writeHeader
    * 可以调用setHeader多次设置，但只有调用writeHeader后，才会写入到连接中。
    * Date、Connection等响应头字段，node自动添加上了。
* 报文体api: res.write和res.end
    * end会先调用write发送数据，然后发送信号告知服务器这次响应结束

> 务必在结束时调用res.end结束请求。

> 一旦开始了发送数据，setHeader和writeHeader将不再生效