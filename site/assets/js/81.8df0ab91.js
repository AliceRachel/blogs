(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{397:function(e,r,i){"use strict";i.r(r);var s=i(9),t=Object(s.a)({},function(){var e=this,r=e.$createElement,i=e._self._c||r;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h1",{attrs:{id:"promise"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#promise","aria-hidden":"true"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),i("h4",{attrs:{id:"为什么要有promise"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#为什么要有promise","aria-hidden":"true"}},[e._v("#")]),e._v(" 为什么要有Promise")]),e._v(" "),i("p",[e._v("回调函数表达异步和并发有两个主要缺陷："),i("code",[e._v("缺乏顺序性和可信任性")]),e._v("。\nPromise封装了依赖时间的状态--等待底层值的完成或拒绝，所以Promise本身与时间无关。因此Promise可以按照可预测的方式组成（组合），而不用关心时序或底层的结果。\n另外，一旦Promise决议，它就永远保持在这个状态。")]),e._v(" "),i("ul",[i("li",[e._v("对象\n"),i("ul",[i("li",[e._v("Promise.resolve()")]),e._v(" "),i("li",[e._v("Promise.reject()")]),e._v(" "),i("li",[e._v("Promise.all([promises]) 并发")]),e._v(" "),i("li",[e._v("Promise.race([promises]) 竞争")])])]),e._v(" "),i("li",[e._v("实例\n"),i("ul",[i("li",[e._v("promise.then()")]),e._v(" "),i("li",[e._v("promise.catch()")]),e._v(" "),i("li",[e._v("promise.finally()")])])])]),e._v(" "),i("h4",{attrs:{id:"promise局限性"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#promise局限性","aria-hidden":"true"}},[e._v("#")]),e._v(" Promise局限性")]),e._v(" "),i("ul",[i("li",[e._v("单一值。Promise只能有一个完成值或拒绝值。")]),e._v(" "),i("li",[e._v("单决议。")]),e._v(" "),i("li",[e._v("无法取消的Promise。")]),e._v(" "),i("li",[e._v("Promise性能。")]),e._v(" "),i("li",[e._v("顺序错误处理。")])]),e._v(" "),i("h2",{attrs:{id:"总结"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),i("p",[e._v("Promise解决了因只用回调的代码而备受困扰的"),i("code",[e._v("控制反转")]),e._v("问题。\n但Promise也没有摈弃回调，只是把回调的安排转交给一位可信任的中介机制。")])])},[],!1,null,null,null);t.options.__file="2.js-base-promise.md";r.default=t.exports}}]);