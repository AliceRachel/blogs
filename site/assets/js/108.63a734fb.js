(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{344:function(e,t,r){"use strict";r.r(t);var v=r(9),a=Object(v.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"vue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue")]),e._v(" "),r("h2",{attrs:{id:"vue-的模板如何被渲染成-html-以及渲染过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-的模板如何被渲染成-html-以及渲染过程","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue 的模板如何被渲染成 HTML? 以及渲染过程")]),e._v(" "),r("ol",[r("li",[e._v("vue 模板的本质是字符串，利用各种正则，把模板中的属性去变成 js 中的变量，vif,vshow,vfor 等指令变成 js 中的逻辑")]),e._v(" "),r("li",[e._v("模板最终会被转换为 render 函数")]),e._v(" "),r("li",[e._v("render 函数执行返回 vNode")]),e._v(" "),r("li",[e._v("使用 vNode 的 path 方法把 vNode 渲染成真实 DOM")])]),e._v(" "),r("h2",{attrs:{id:"vue-的整个实现流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-的整个实现流程","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue 的整个实现流程")]),e._v(" "),r("ol",[r("li",[e._v("先把模板解析成 render 函数，把模板中的属性去变成 js 中的变量，vif,vshow,vfor 等指令变成 js 中的逻辑")]),e._v(" "),r("li",[e._v("执行 render 函数，在初次渲染执行 render 函数的过程中 绑定属性监听，收集依赖，最终得到 vNode，利用 vNode 的 Path 方法，把 vNode 渲染成真实的 DOM")]),e._v(" "),r("li",[e._v("在属性更新后，重新执行 render 函数，不过这个时候就不需要绑定属性和收集依赖了，最终生成新的 vNode")]),e._v(" "),r("li",[e._v("把新的 vNode 和 旧的 vNode 去做对比，找出真正需要更新的 DOM，渲染")])]),e._v(" "),r("h2",{attrs:{id:"什么是-diff-算法，或者是-diff-算法用来做什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是-diff-算法，或者是-diff-算法用来做什么","aria-hidden":"true"}},[e._v("#")]),e._v(" 什么是 diff 算法，或者是 diff 算法用来做什么")])])},[],!1,null,null,null);a.options.__file="vue-question.md";t.default=a.exports}}]);